exit
b[[1,1]].movement
b[[0,2]].movement
b[[0,2]]
b[[0,3]].movement
b = Board.new
find_king :black
c
display self
exit
displ self
exit
display self
exit
display self
self
c
piece
self
c
self
piece
c
in_check?(:black)
piece.movement.include?(throne)
throne
find_king :black
find_king? :black
piece.movement
peice.movement
display piece
exit
piece.moves
find_king(color).pos
c
find_king(color).pos
c
find_king(color).pos
throne
c
throne = find_king(color).pos
find_king(color).pos
find_king :black
color
throne
c
find_king :black
@rows
piece
peice
c
piece
exit
move
piece
c
exit
c
vine
c
piece
c
piece
c
display throne
display piece
display piece.movement.include?(throne)
piece.movement.include?(throne)
throne
piece
throne
c
throne
c
throne
exit
in_check?(color)
move
piece
c
display piece
c
piece.moves
c
display break_check?(piece, move, color)
display piece
display color
exit
select_pieces(color)
color
black
display piece
exit
c
 c
c
display piece
c
exit
@rows
@chessboard
@chessboard.rows
@chessboard
@board
piece.moves
piece.movement
piece.pos
piece.movement
c
display piece.movement.include?(throne)
display piece
piece
select_pieces(opp_color)
throne
color
opp_color
c
@chessboard.in_check?(:black)
checkmate?
c
checkmate?
c
display @players[0].color
c
 @chessboard.checkmate?(@players[0].color)
@players[0].color
c
exit
c
display break_check?(piece, move, color)
display piece
c
move
piece.movement
piece
display movement
c
@chessboard.checkmate?(@players[0].color)
@players[0].color
c
in_check?(color)
color
c
color
exit
@board[step].color != @color
collision?(step)
c
display @valid_moves
display step
c
step
display step
step
n
@pos
display @valid_moves
